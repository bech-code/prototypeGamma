#!/usr/bin/env python3
"""
Script de test pour v√©rifier que tous les correctifs ont √©t√© appliqu√©s correctement.
"""

import requests
import json
import time
from datetime import datetime

# Configuration
BASE_URL = "http://127.0.0.1:8000"
ADMIN_TOKEN = None
TECHNICIAN_TOKEN = None
CLIENT_TOKEN = None

def login_user(username, password):
    """Connexion d'un utilisateur et r√©cup√©ration du token."""
    try:
        response = requests.post(f"{BASE_URL}/users/login/", json={
            "username": username,
            "password": password
        })
        
        if response.status_code == 200:
            data = response.json()
            return data.get("access")
        else:
            print(f"‚ùå √âchec de connexion pour {username}: {response.status_code}")
            return None
    except Exception as e:
        print(f"‚ùå Erreur de connexion pour {username}: {e}")
        return None

def test_endpoint(endpoint, method="GET", data=None, expected_status=200, description=""):
    """Test d'un endpoint avec gestion des tokens."""
    global ADMIN_TOKEN, TECHNICIAN_TOKEN, CLIENT_TOKEN
    
    # D√©terminer quel token utiliser selon l'endpoint
    if "admin" in endpoint:
        token = ADMIN_TOKEN
        user_type = "admin"
    elif "technician" in endpoint or "technicians" in endpoint:
        token = TECHNICIAN_TOKEN
        user_type = "technician"
    else:
        token = CLIENT_TOKEN
        user_type = "client"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    } if token else {}
    
    try:
        if method == "GET":
            response = requests.get(f"{BASE_URL}{endpoint}", headers=headers)
        elif method == "POST":
            response = requests.post(f"{BASE_URL}{endpoint}", headers=headers, json=data)
        elif method == "PATCH":
            response = requests.patch(f"{BASE_URL}{endpoint}", headers=headers, json=data)
        else:
            print(f"‚ùå M√©thode {method} non support√©e")
            return False
        
        if response.status_code == expected_status:
            print(f"‚úÖ {description} - {method} {endpoint} ({response.status_code})")
            assert True, f"{description} - {method} {endpoint} OK"
        else:
            print(f"‚ùå {description} - {method} {endpoint} ({response.status_code}) - {response.text}")
            assert False, f"{description} - {method} {endpoint} √©chou√© : {response.status_code}"
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test {description}: {e}")
        assert False, f"Erreur lors du test {description}: {e}"

def test_pagination(endpoint, description=""):
    """Test de la pagination sur un endpoint."""
    global ADMIN_TOKEN
    
    headers = {
        "Authorization": f"Bearer {ADMIN_TOKEN}",
        "Content-Type": "application/json"
    }
    
    try:
        # Test avec pagination
        response = requests.get(f"{BASE_URL}{endpoint}?page=1&page_size=5", headers=headers)
        
        if response.status_code == 200:
            data = response.json()
            if "results" in data and "count" in data:
                print(f"‚úÖ Pagination fonctionnelle pour {description}")
                assert True, f"Pagination fonctionnelle pour {description}"
            else:
                print(f"‚ùå Pagination manquante pour {description}")
                assert False, f"Pagination manquante pour {description}"
        else:
            print(f"‚ùå Erreur de pagination pour {description}: {response.status_code}")
            assert False, f"Erreur de pagination pour {description}: {response.status_code}"
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test de pagination {description}: {e}")
        assert False, f"Erreur lors du test de pagination {description}: {e}"

def test_rate_limiting():
    """Test de la limitation de d√©bit."""
    print("\nüîí Test de la limitation de d√©bit...")
    
    # Test de connexion multiple
    for i in range(10):
        response = requests.post(f"{BASE_URL}/users/login/", {
            "username": "test_user",
            "password": "wrong_password"
        })
        
        if response.status_code == 429:  # Too Many Requests
            print(f"‚úÖ Limitation de d√©bit activ√©e apr√®s {i+1} tentatives")
            assert True, f"Limitation de d√©bit activ√©e apr√®s {i+1} tentatives"
    
    print("‚ùå Limitation de d√©bit non activ√©e")
    assert False, "Limitation de d√©bit non activ√©e"

def test_security_headers():
    """Test des en-t√™tes de s√©curit√©."""
    print("\nüõ°Ô∏è Test des en-t√™tes de s√©curit√©...")
    
    try:
        response = requests.get(f"{BASE_URL}/depannage/api/test/health_check/")
        
        headers = response.headers
        security_headers = {
            "X-Frame-Options": "DENY",
            "X-Content-Type-Options": "nosniff",
            "X-XSS-Protection": "1; mode=block"
        }
        
        for header, expected_value in security_headers.items():
            if header in headers:
                print(f"‚úÖ En-t√™te de s√©curit√© {header} pr√©sent")
            else:
                print(f"‚ùå En-t√™te de s√©curit√© {header} manquant")
        
        assert True, "En-t√™tes de s√©curit√© test√©s avec succ√®s"
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test des en-t√™tes de s√©curit√©: {e}")
        assert False, f"Erreur lors du test des en-t√™tes de s√©curit√©: {e}"

def test_data_validation():
    """Test de la validation des donn√©es."""
    print("\nüìù Test de la validation des donn√©es...")
    
    global CLIENT_TOKEN
    
    headers = {
        "Authorization": f"Bearer {CLIENT_TOKEN}",
        "Content-Type": "application/json"
    }
    
    # Test avec des donn√©es invalides
    invalid_data = {
        "title": "A",  # Trop court
        "description": "B",  # Trop court
        "specialty_needed": "invalid_specialty"
    }
    
    try:
        response = requests.post(f"{BASE_URL}/depannage/api/repair-requests/", 
                               headers=headers, json=invalid_data)
        
        if response.status_code == 400:
            print("‚úÖ Validation des donn√©es fonctionnelle")
            assert True, "Validation des donn√©es fonctionnelle"
        else:
            print(f"‚ùå Validation des donn√©es √©chou√©e: {response.status_code}")
            assert False, f"Validation des donn√©es √©chou√©e: {response.status_code}"
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test de validation: {e}")
        assert False, f"Erreur lors du test de validation: {e}"

def main():
    """Fonction principale de test."""
    global ADMIN_TOKEN, TECHNICIAN_TOKEN, CLIENT_TOKEN
    
    print("üöÄ Test des correctifs appliqu√©s")
    print("=" * 50)
    
    # Connexion des utilisateurs de test
    print("\nüîê Connexion des utilisateurs de test...")
    
    ADMIN_TOKEN = login_user("admin", "admin123")
    TECHNICIAN_TOKEN = login_user("technician1", "password123")
    CLIENT_TOKEN = login_user("client1", "password123")
    
    if not all([ADMIN_TOKEN, TECHNICIAN_TOKEN, CLIENT_TOKEN]):
        print("‚ùå Impossible de se connecter avec tous les utilisateurs de test")
        return
    
    print("‚úÖ Connexion r√©ussie pour tous les utilisateurs")
    
    # Test des nouveaux endpoints
    print("\nüì° Test des nouveaux endpoints...")
    
    new_endpoints = [
        ("/users/me/", "GET", None, 200, "Informations utilisateur"),
        ("/depannage/api/admin/dashboard/stats/", "GET", None, 200, "Statistiques admin"),
        ("/depannage/api/admin/notifications/", "GET", None, 200, "Notifications admin"),
        ("/depannage/api/admin/reviews/", "GET", None, 200, "Avis admin"),
        ("/depannage/api/admin/payments/", "GET", None, 200, "Paiements admin"),
        ("/depannage/api/admin/payments/stats/", "GET", None, 200, "Statistiques paiements"),
        ("/depannage/api/admin/security/alerts/recent/", "GET", None, 200, "Alertes s√©curit√©"),
        ("/depannage/api/admin/security/login-locations/", "GET", None, 200, "Localisations connexion"),
        ("/depannage/api/configuration/", "GET", None, 200, "Configuration syst√®me"),
        ("/depannage/api/technicians/dashboard/", "GET", None, 200, "Dashboard technicien"),
    ]
    
    success_count = 0
    for endpoint, method, data, expected_status, description in new_endpoints:
        if test_endpoint(endpoint, method, data, expected_status, description):
            success_count += 1
    
    print(f"\nüìä R√©sultat des nouveaux endpoints: {success_count}/{len(new_endpoints)} r√©ussis")
    
    # Test de la pagination
    print("\nüìÑ Test de la pagination...")
    
    pagination_endpoints = [
        ("/depannage/api/repair-requests/", "Demandes de r√©paration"),
        ("/depannage/api/reviews/", "Avis"),
        ("/depannage/api/payments/", "Paiements"),
        ("/depannage/api/notifications/", "Notifications"),
    ]
    
    pagination_success = 0
    for endpoint, description in pagination_endpoints:
        if test_pagination(endpoint, description):
            pagination_success += 1
    
    print(f"üìä R√©sultat de la pagination: {pagination_success}/{len(pagination_endpoints)} r√©ussis")
    
    # Test de la s√©curit√©
    test_rate_limiting()
    test_security_headers()
    test_data_validation()
    
    # Test des optimisations de performance
    print("\n‚ö° Test des optimisations de performance...")
    
    # Test avec select_related
    try:
        response = requests.get(f"{BASE_URL}/depannage/api/repair-requests/", 
                              headers={"Authorization": f"Bearer {CLIENT_TOKEN}"})
        
        if response.status_code == 200:
            data = response.json()
            if "results" in data:
                print("‚úÖ Optimisation des requ√™tes avec select_related")
                assert True, "Optimisation des requ√™tes avec select_related"
            else:
                print("‚ùå Optimisation des requ√™tes non d√©tect√©e")
                assert False, "Optimisation des requ√™tes non d√©tect√©e"
        else:
            print(f"‚ùå Erreur lors du test d'optimisation: {response.status_code}")
            assert False, f"Erreur lors du test d'optimisation: {response.status_code}"
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test d'optimisation: {e}")
        assert False, f"Erreur lors du test d'optimisation: {e}"
    
    # Test du cache
    print("\nüíæ Test du cache...")
    try:
        start_time = time.time()
        response1 = requests.get(f"{BASE_URL}/depannage/api/admin/dashboard/stats/", 
                               headers={"Authorization": f"Bearer {ADMIN_TOKEN}"})
        time1 = time.time() - start_time
        
        start_time = time.time()
        response2 = requests.get(f"{BASE_URL}/depannage/api/admin/dashboard/stats/", 
                               headers={"Authorization": f"Bearer {ADMIN_TOKEN}"})
        time2 = time.time() - start_time
        
        if time2 < time1:
            print("‚úÖ Cache fonctionnel (deuxi√®me requ√™te plus rapide)")
            assert True, "Cache fonctionnel (deuxi√®me requ√™te plus rapide)"
        else:
            print("‚ö†Ô∏è Cache potentiellement non fonctionnel")
            assert False, "Cache potentiellement non fonctionnel"
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test du cache: {e}")
        assert False, f"Erreur lors du test du cache: {e}"
    
    print("\nüéâ Tests termin√©s!")

if __name__ == "__main__":
    main() 