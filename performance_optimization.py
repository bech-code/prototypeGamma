#!/usr/bin/env python3
"""
Script d'optimisation des performances pour les endpoints des techniciens
Analyse et recommande des am√©liorations pour la pagination et les requ√™tes
"""

import re
import os
from typing import Dict, List, Set
from dataclasses import dataclass

@dataclass
class PerformanceIssue:
    endpoint: str
    issue_type: str
    severity: str
    description: str
    recommendation: str
    impact: str

@dataclass
class QueryAnalysis:
    endpoint: str
    query_count: int
    has_pagination: bool
    has_select_related: bool
    has_prefetch_related: bool
    n_plus_one_risk: bool

class PerformanceOptimizer:
    def __init__(self):
        self.performance_issues: List[PerformanceIssue] = []
        self.query_analyses: List[QueryAnalysis] = []
        self.endpoints_without_pagination: List[str] = []
        self.endpoints_with_n_plus_one: List[str] = []
        
    def analyze_pagination_usage(self):
        """Analyse l'utilisation de la pagination"""
        print("üìÑ Analyse de l'utilisation de la pagination...")
        
        view_files = [
            "Backend/depannage/views.py",
            "Backend/users/views.py",
        ]
        
        for view_file in view_files:
            if os.path.exists(view_file):
                try:
                    with open(view_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Chercher les patterns de pagination
                    pagination_patterns = [
                        r'pagination_class',
                        r'PageNumberPagination',
                        r'LimitOffsetPagination',
                        r'CursorPagination',
                        r'\.paginate',
                    ]
                    
                    # Chercher les endpoints qui retournent des listes
                    list_endpoints = [
                        'list',
                        'available_technicians',
                        'received',
                        'pending_reviews',
                        'my_payments',
                        'notifications',
                    ]
                    
                    for endpoint_name in list_endpoints:
                        # Chercher la m√©thode dans le fichier
                        method_pattern = rf'def {endpoint_name}\('
                        if re.search(method_pattern, content):
                            # V√©rifier si la pagination est utilis√©e
                            has_pagination = any(re.search(pattern, content) for pattern in pagination_patterns)
                            
                            if not has_pagination:
                                endpoint_url = self.get_endpoint_url(endpoint_name)
                                self.endpoints_without_pagination.append(endpoint_url)
                                self.performance_issues.append(PerformanceIssue(
                                    endpoint=endpoint_url,
                                    issue_type="Pagination",
                                    severity="MEDIUM",
                                    description=f"Endpoint {endpoint_name} sans pagination",
                                    recommendation="Impl√©menter la pagination pour am√©liorer les performances",
                                    impact="Peut causer des temps de r√©ponse lents avec de grandes listes"
                                ))
                
                except Exception as e:
                    print(f"‚ùå Erreur lecture {view_file}: {e}")
        
        print(f"‚úÖ {len(self.endpoints_without_pagination)} endpoints sans pagination trouv√©s")
    
    def analyze_query_optimization(self):
        """Analyse l'optimisation des requ√™tes"""
        print("üîç Analyse de l'optimisation des requ√™tes...")
        
        view_files = [
            "Backend/depannage/views.py",
            "Backend/users/views.py",
        ]
        
        for view_file in view_files:
            if os.path.exists(view_file):
                try:
                    with open(view_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Chercher les patterns d'optimisation
                    select_related_patterns = [
                        r'\.select_related\(',
                        r'\.prefetch_related\(',
                        r'\.only\(',
                        r'\.defer\(',
                    ]
                    
                    # Chercher les patterns de requ√™tes multiples
                    n_plus_one_patterns = [
                        r'for.*in.*\.objects\.all\(\)',
                        r'for.*in.*\.objects\.filter\(',
                        r'\.objects\.get\(.*\)\.',
                    ]
                    
                    # Analyser chaque endpoint
                    endpoints_to_analyze = [
                        'dashboard_stats',
                        'rewards',
                        'subscription_status',
                        'received',
                        'available_technicians',
                    ]
                    
                    for endpoint_name in endpoints_to_analyze:
                        method_pattern = rf'def {endpoint_name}\('
                        if re.search(method_pattern, content):
                            # Extraire le contexte de la m√©thode
                            method_start = content.find(f'def {endpoint_name}(')
                            if method_start != -1:
                                # Chercher la fin de la m√©thode (prochaine fonction ou fin de classe)
                                method_end = content.find('\n\n', method_start)
                                if method_end == -1:
                                    method_end = len(content)
                                
                                method_content = content[method_start:method_end]
                                
                                # Analyser les optimisations
                                has_select_related = any(re.search(pattern, method_content) for pattern in select_related_patterns)
                                has_n_plus_one = any(re.search(pattern, method_content) for pattern in n_plus_one_patterns)
                                
                                endpoint_url = self.get_endpoint_url(endpoint_name)
                                
                                self.query_analyses.append(QueryAnalysis(
                                    endpoint=endpoint_url,
                                    query_count=self.count_queries(method_content),
                                    has_pagination=False,  # √Ä am√©liorer
                                    has_select_related=has_select_related,
                                    has_prefetch_related=has_select_related,
                                    n_plus_one_risk=has_n_plus_one
                                ))
                                
                                if has_n_plus_one:
                                    self.endpoints_with_n_plus_one.append(endpoint_url)
                                    self.performance_issues.append(PerformanceIssue(
                                        endpoint=endpoint_url,
                                        issue_type="N+1 Query",
                                        severity="HIGH",
                                        description=f"Risque de requ√™tes N+1 dans {endpoint_name}",
                                        recommendation="Utiliser select_related() ou prefetch_related()",
                                        impact="Peut causer des centaines de requ√™tes pour de grandes listes"
                                    ))
                
                except Exception as e:
                    print(f"‚ùå Erreur lecture {view_file}: {e}")
        
        print(f"‚úÖ {len(self.endpoints_with_n_plus_one)} endpoints avec risque N+1 trouv√©s")
    
    def analyze_database_indexes(self):
        """Analyse l'utilisation des index de base de donn√©es"""
        print("üóÑÔ∏è Analyse des index de base de donn√©es...")
        
        model_files = [
            "Backend/depannage/models.py",
            "Backend/users/models.py",
        ]
        
        for model_file in model_files:
            if os.path.exists(model_file):
                try:
                    with open(model_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Chercher les mod√®les fr√©quemment utilis√©s
                    frequent_models = [
                        'Technician',
                        'RepairRequest',
                        'Review',
                        'Payment',
                        'Notification',
                    ]
                    
                    for model_name in frequent_models:
                        # Chercher le mod√®le
                        model_pattern = rf'class {model_name}\('
                        if re.search(model_pattern, content):
                            # V√©rifier les index
                            index_patterns = [
                                r'db_index=True',
                                r'indexes\s*=\s*\[',
                                r'unique_together',
                                r'index_together',
                            ]
                            
                            has_indexes = any(re.search(pattern, content) for pattern in index_patterns)
                            
                            if not has_indexes:
                                self.performance_issues.append(PerformanceIssue(
                                    endpoint=f"Model: {model_name}",
                                    issue_type="Database Index",
                                    severity="MEDIUM",
                                    description=f"Mod√®le {model_name} sans index optimis√©s",
                                    recommendation="Ajouter des index sur les champs fr√©quemment filtr√©s",
                                    impact="Requ√™tes de filtrage lentes"
                                ))
                
                except Exception as e:
                    print(f"‚ùå Erreur lecture {model_file}: {e}")
        
        print("‚úÖ Analyse des index termin√©e")
    
    def analyze_caching_strategy(self):
        """Analyse la strat√©gie de mise en cache"""
        print("üíæ Analyse de la strat√©gie de mise en cache...")
        
        view_files = [
            "Backend/depannage/views.py",
            "Backend/users/views.py",
        ]
        
        for view_file in view_files:
            if os.path.exists(view_file):
                try:
                    with open(view_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Chercher les patterns de cache
                    cache_patterns = [
                        r'@cache_page',
                        r'cache\.get\(',
                        r'cache\.set\(',
                        r'from django\.core\.cache',
                    ]
                    
                    has_caching = any(re.search(pattern, content) for pattern in cache_patterns)
                    
                    if not has_caching:
                        # Chercher les endpoints qui pourraient b√©n√©ficier du cache
                        cacheable_endpoints = [
                            'dashboard_stats',
                            'rewards',
                            'project_statistics',
                            'available_technicians',
                        ]
                        
                        for endpoint_name in cacheable_endpoints:
                            if re.search(rf'def {endpoint_name}\(', content):
                                endpoint_url = self.get_endpoint_url(endpoint_name)
                                self.performance_issues.append(PerformanceIssue(
                                    endpoint=endpoint_url,
                                    issue_type="Caching",
                                    severity="LOW",
                                    description=f"Endpoint {endpoint_name} sans mise en cache",
                                    recommendation="Impl√©menter la mise en cache pour les donn√©es statiques",
                                    impact="Requ√™tes r√©p√©t√©es inutiles"
                                ))
                
                except Exception as e:
                    print(f"‚ùå Erreur lecture {view_file}: {e}")
        
        print("‚úÖ Analyse de la mise en cache termin√©e")
    
    def count_queries(self, method_content: str) -> int:
        """Compte le nombre de requ√™tes dans une m√©thode"""
        query_patterns = [
            r'\.objects\.',
            r'\.filter\(',
            r'\.get\(',
            r'\.all\(',
            r'\.aggregate\(',
        ]
        
        count = 0
        for pattern in query_patterns:
            count += len(re.findall(pattern, method_content))
        
        return count
    
    def get_endpoint_url(self, method_name: str) -> str:
        """Retourne l'URL de l'endpoint bas√© sur le nom de la m√©thode"""
        endpoint_mapping = {
            'dashboard_stats': '/depannage/api/repair-requests/dashboard_stats/',
            'rewards': '/depannage/api/reviews/rewards/',
            'subscription_status': '/depannage/api/technicians/subscription_status/',
            'received': '/depannage/api/reviews/received/',
            'available_technicians': '/depannage/api/repair-requests/available_technicians/',
            'project_statistics': '/depannage/api/repair-requests/project_statistics/',
            'my_payments': '/depannage/api/payments/my_payments/',
            'notifications': '/depannage/api/notifications/',
        }
        
        return endpoint_mapping.get(method_name, f"/depannage/api/{method_name}/")
    
    def generate_optimization_report(self):
        """G√©n√®re un rapport d'optimisation d√©taill√©"""
        print("\n" + "="*80)
        print("‚ö° RAPPORT D'OPTIMISATION DES PERFORMANCES")
        print("="*80)
        
        # Statistiques
        total_issues = len(self.performance_issues)
        high_issues = len([i for i in self.performance_issues if i.severity == "HIGH"])
        medium_issues = len([i for i in self.performance_issues if i.severity == "MEDIUM"])
        low_issues = len([i for i in self.performance_issues if i.severity == "LOW"])
        
        print(f"\nüìä Statistiques de performance:")
        print(f"   Total des probl√®mes: {total_issues}")
        print(f"   √âlev√©: {high_issues}")
        print(f"   Moyen: {medium_issues}")
        print(f"   Faible: {low_issues}")
        
        # Analyse des requ√™tes
        print(f"\nüîç Analyse des requ√™tes:")
        for analysis in self.query_analyses:
            print(f"   {analysis.endpoint}:")
            print(f"      Requ√™tes: {analysis.query_count}")
            print(f"      N+1 risque: {'Oui' if analysis.n_plus_one_risk else 'Non'}")
            print(f"      Optimisations: {'Oui' if analysis.has_select_related else 'Non'}")
        
        # Probl√®mes par type
        print(f"\nüîç Probl√®mes par type:")
        issue_types = {}
        for issue in self.performance_issues:
            issue_types[issue.issue_type] = issue_types.get(issue.issue_type, 0) + 1
        
        for issue_type, count in issue_types.items():
            print(f"   {issue_type}: {count}")
        
        # Probl√®mes √©lev√©s
        if high_issues > 0:
            print(f"\nüö® Probl√®mes √âLEV√âS:")
            for issue in self.performance_issues:
                if issue.severity == "HIGH":
                    print(f"   ‚ùå {issue.endpoint}")
                    print(f"      {issue.description}")
                    print(f"      Recommandation: {issue.recommendation}")
                    print(f"      Impact: {issue.impact}")
                    print()
        
        # Probl√®mes moyens
        if medium_issues > 0:
            print(f"\n‚ö†Ô∏è  Probl√®mes MOYENS:")
            for issue in self.performance_issues:
                if issue.severity == "MEDIUM":
                    print(f"   ‚ö†Ô∏è  {issue.endpoint}")
                    print(f"      {issue.description}")
                    print(f"      Recommandation: {issue.recommendation}")
                    print(f"      Impact: {issue.impact}")
                    print()
        
        # Recommandations d'optimisation
        print(f"\nüí° Recommandations d'optimisation:")
        if high_issues > 0:
            print(f"   üö® Corrigez imm√©diatement les {high_issues} probl√®mes √©lev√©s")
        
        if medium_issues > 0:
            print(f"   ‚ö†Ô∏è  Traitez en priorit√© les {medium_issues} probl√®mes moyens")
        
        if low_issues > 0:
            print(f"   üìù Planifiez l'am√©lioration des {low_issues} probl√®mes faibles")
        
        # Bonnes pratiques
        print(f"\n‚úÖ Bonnes pratiques de performance:")
        print(f"   ‚Ä¢ Utilisez la pagination pour toutes les listes")
        print(f"   ‚Ä¢ Impl√©mentez select_related() et prefetch_related()")
        print(f"   ‚Ä¢ Ajoutez des index sur les champs fr√©quemment filtr√©s")
        print(f"   ‚Ä¢ Mettez en cache les donn√©es statiques")
        print(f"   ‚Ä¢ Utilisez .only() et .defer() pour limiter les champs")
        print(f"   ‚Ä¢ Impl√©mentez la compression gzip")
        print(f"   ‚Ä¢ Utilisez des requ√™tes optimis√©es avec des annotations")
        
        # Exemples d'optimisation
        print(f"\nüìù Exemples d'optimisation:")
        print(f"   # Avant (N+1 queries)")
        print(f"   technicians = Technician.objects.all()")
        print(f"   for tech in technicians:")
        print(f"       print(tech.user.email)  # Requ√™te suppl√©mentaire")
        print(f"   ")
        print(f"   # Apr√®s (optimis√©)")
        print(f"   technicians = Technician.objects.select_related('user').all()")
        print(f"   for tech in technicians:")
        print(f"       print(tech.user.email)  # Pas de requ√™te suppl√©mentaire)")
        
        print(f"\nüéØ Rapport d'optimisation termin√©!")
    
    def run_optimization_analysis(self):
        """Ex√©cute l'analyse d'optimisation compl√®te"""
        print("üöÄ D√©marrage de l'analyse d'optimisation...")
        
        self.analyze_pagination_usage()
        self.analyze_query_optimization()
        self.analyze_database_indexes()
        self.analyze_caching_strategy()
        self.generate_optimization_report()

if __name__ == "__main__":
    optimizer = PerformanceOptimizer()
    optimizer.run_optimization_analysis() 